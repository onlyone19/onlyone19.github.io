---
title: Sort Algorithm
category: Blog
tags:
  - leetcode
  - sorting
---

## Select sort
- `i~n-1范围上，找到最小值并放在i位置，然后i+1~n-1范围上继续`


## Bubble sort
- `0~i范围上，相邻位置较大的数滚下去，最大值最终来到i位置，然后0~i-1范围上继续`

## Insert Sort
- `0~i范围上已经有序，新来的数从右到左滑到不再小的位置插入，然后继续`


## Merge Sort
1. 左部分排好序、右部分排好序、利用merge过程让左右整体有序
2. merge过程：谁小拷贝谁，直到左右两部分所有的数字耗尽，拷贝回原数组
3. 递归实现和非递归实现
4. 时间复杂度O(n * logn)
5. 需要辅助数组，所以额外空间复杂度O(n)


## Quick Sort
1. 经典随机快速排序流程讲解
2. 荷兰国旗问题优化随机快速排序流程讲解
3. 普通快速排序，时间复杂度O(n^2)，额外空间复杂度O(n)
4. 随机快速排序，时间复杂度O(n * logn)，额外空间复杂度O(logn)


## Heap Sort
- i的父亲节点：(i-1)/2，
- i的左孩子：i*2 + 1，
- i的右孩子：i*2 + 2
- 堆排序
   - A. 从顶到底建堆，时间复杂度O(n * log n)，log1 + log2 + log3 + … + logn -> O(n*logn)
      或者用增倍分析法：建堆的复杂度分析+子矩阵数量的复杂度分析
   - B. 从底到顶建堆，时间复杂度O(n)，总代价就是简单的等比数列关系，为啥会有差异？
   C. 建好堆之后的调整阶段，从最大值到最小值依次归位，时间复杂度O(n * log n)

- https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6
- https://leetcode.com/problems/meeting-rooms-ii/
- https://leetcode.com/problems/minimum-operations-to-halve-array-sum/

## 计数排序，
- 非常简单，但是数值范围比较大了就不行了

## 基数排序
- 关键点：
  1. 前缀数量分区的技巧、
  2. 数字提取某一位的技巧
- 时间复杂度O(n)，额外空间复杂度O(m)，需要辅助空间做类似桶的作用，来不停的装入、弹出数字

## Binary Search
- https://stackoverflow.com/questions/41125190/why-java-arrays-binarysearch-return-insertion-point-1-when-not-found
- https://stackoverflow.com/questions/28389065/difference-between-basic-binary-search-for-upper-bound-and-lower-bound
- [162. Find Peak Element](https://leetcode.com/problems/find-peak-element)

## 随机选择算法
- https://leetcode.com/problems/kth-largest-element-in-an-array/

## 归并分治
1. 思考一个问题在大范围上的答案，是否等于，左部分的答案 + 右部分的答案 + 跨越左右产生的答案
2. **计算“跨越左右产生的答案”时，如果加上左、右各自有序这个设定，会不会获得计算的便利性**
3. 如果以上两点都成立，那么该问题很可能被归并分治解决（话不说满，因为总有很毒的出题人）
4. 求解答案的过程中只需要加入归并排序的过程即可，因为要让左、右各自有序，来获得计算的便利性

5. 小和问题: https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469
  ```
  假设数组 s = [ 1, 3, 5, 2, 4, 6]
  在s[0]的左边所有 <= s[0]的数的总和为0
  在s[1]的左边所有 <= s[1]的数的总和为1
  在s[2]的左边所有 <= s[2]的数的总和为4
  在s[3]的左边所有 <= s[3]的数的总和为1
  在s[4]的左边所有 <= s[4]的数的总和为6
  在s[5]的左边所有 <= s[5]的数的总和为15
  所以s数组的“小和”为 : 0 + 1 + 4 + 1 + 6 + 15 = 27
  给定一个数组arr，实现函数返回arr的“小和”
  ```
7. reverse pair: https://leetcode.cn/problems/reverse-pairs/
```
给定一个数组 nums ，
如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个翻转对
你需要返回给定数组中的翻转对的数量
```




